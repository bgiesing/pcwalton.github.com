<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">
    <meta charset="utf-8"></meta>
</head>
<body>
    <div class=reveal>
        <div class=slides>
            <section>
                <h1>WebRender</h1>
                <h2>Patrick Walton
                    <br>
                    <a style="text-transform: none; font-size: smaller; font-family: monospace;">
                        pcwalton@mozilla.com
                    </a>
                </h2>
            </section>
            <section>
                <h1>Topics</h1>
                <ul>
                    <li>Why WebRender?</li>
                    <li>What is WebRender?</li>
                    <li>How does WebRender work?</li>
                    <li>Show me WebRender!</li>
                </ul>
            </section>
            <section>
                <h1>Why WebRender?</h1>
            </section>
            <section>
                <h2>Haswell CPU</h2>
                <img src=assets/haswell-die.jpg>
            </section>
            <section>
                <h2>Broadwell CPU</h2>
                <img height=500 src=assets/broadwell-die.png>
            </section>
            <section>
                <h2>Skylake CPU</h2>
                <img height=500 src=assets/skylake-die.jpg>
            </section>
            <section>
                <h2>Why use the GPU?</h2>
                <ul>
                    <li>Intel isn't giving us more CPU cores to work with.</li>
                    <li>CPU cores aren't getting much faster.</li>
                    <li>But the GPU is advancing steadily with each hardware revision.</li>
                    <li>
                        And GPUs are ubiquitous.
                        <ul>
                            <li>
                                Even the $5 Raspberry Pi Zero has 24 GFLOPS available in the
                                GPU!
                            </li>
                        </ul>
                    </li>
                </ul>
            </section>
            <section>
                <h2>Why not use an existing engine?</h2>
                <ul>
                    <li>
                        Ganesh (Skia), Direct2D, Quartz/Core Graphics all use the GPU to varying
                        degrees.
                    </li>
                    <li>
                        These are great libraries if you need a drop-in replacement for a
                        CPU-based, immediate mode API.
                        <ul>
                            <li>
                                For example, Skia makes a very good rendering backend for the
                                <code>&lt;canvas&gt;</code> element.
                            </li>
                        </ul>
                    </li>
                    <li>But, for a GPU, immediate mode has drawbacks…</li>
                </ul>
            </section>
            <section>
                <h2>Why retained mode?</h2>
                <ul>
                    <li>
                        Immediate mode doesn't map well to the GPU unless the code driving the API
                        is careful to batch and avoid excessive state changes.
                    </li>
                    <li>
                        But vector graphics APIs that were originally designed for CPUs hide state
                        changes and don't offer many opportunities for batching.
                    </li>
                    <li>
                        And having the entire scene ready in advance enables better optimizations…
                        <ul>
                            <li>…for example, culling and Z-buffering to reduce overdraw.</li>
                        </ul>
                    </li>
                    <li>
                        CSS and the DOM are already close to a scene graph: take advantage of that!
                    </li>
                </ul>
            </section>
            <section>
                <h2>What GPU vendors are saying</h2>
                <blockquote>
                    [In existing APIs] path rendering can result in many state changes per path…In
                    this case, the API overhead can substantially limit the overall performance.
                    Our experience…indicates
                    <b>
                        these  approaches  are  often  more  GPU-assisted  rather  than 
                        GPU-accelerated…
                    </b>
                </blockquote>
                <aside style="text-align: right">
                    —Mark Kilgard and Jeff Bolz, NVIDIA<br>
                    SIGGRAPH Asia 2012
                </aside>
            </section>
            <section>
                <h2>What GPU vendors are saying</h2>
                <blockquote>
                    Today web browsers respecify paths every time a web page with path content is
                    re-rendered assuming re-specifying paths is cheap…When  path rendering is fully
                    GPU-accelerated, <b>a retained  model of rendering is more appropriate and
                    efficient</b>. We believe web browsers should behave more like video games in
                    this respect to exploit the GPU.
                </blockquote>
                <aside style="text-align: right">
                    —Mark Kilgard and Jeff Bolz, NVIDIA<br>
                    SIGGRAPH Asia 2012
                </aside>
            </section>
            <section>
                <h2>Why write in Rust?</h2>
                <ul>
                    <li>
                        Low-level systems performance.
                        <ul>
                            <li>We're essentially writing a game engine!</li>
                        </ul>
                    </li>
                    <li>
                        Security and safety.
                        <ul>
                            <li>
                                Modern game engines are multithreaded, so we should be as well.
                            </li>
                            <li>Not chasing data races speeds us up.</li>
                            <li>
                                Memory safety protects against security vulnerabilities, especially
                                around IPC.
                            </li>
                        </ul>
                    </li>
                </ul>
            </section>
            <section>
                <h1>What is WebRender?</h1>
            </section>
            <section>
                <h2>WebRender in a nutshell</h2>
                <ul>
                    <li>
                        WebRender is a specialized, OpenGL-based renderer for CSS content.
                        <ul>
                            <li>
                                It is not a general-purpose vector graphics API: it focuses on CSS.
                            </li>
                        </ul>
                    </li>
                    <li>The engine is a retained mode, multithreaded graphics engine.</li>
                    <li>
                        WebRender takes a post-layout CSS <em>display list</em> and draws it to the
                        screen as quickly as possible.
                    </li>
                </ul>
            </section>
            <section>
                <h2>Sample display list</h2>
                <div>A fragment of a display list from Wikipedia:</div>
                <pre style="font-size: 18px;">├─ Content
│  ├─ Text @ Rect(78.183px×31.9833px at (8px,23.9333px))
│  ├─ Text @ Rect(249.316px×15.9833px at (8px,80.85px))
│  ├─ Text @ Rect(59.5166px×15.9833px at (8px,98.833px))
│  ├─ SolidColor rgba(0, 0, 0, 0) @ Rect(67.5px×15.98px at (67.516px,98.8px))
│  ├─ Text @ Rect(67.5px×15.9833px at (67.516px,98.833px))
│  ├─ BoxShadow @ Rect(67.5px×1.03333px at (67.516px,114.016px))
│  ├─ Text @ Rect(8px×15.9833px at (135.016px,98.833px))
│  ├─ SolidColor rgba(0, 0, 0, 0) @ Rect(40.8px×15.98px at (143.0px,98.8px))
│  ├─ Text @ Rect(40.8333px×15.9833px at (143.016px,98.833px))
│  ├─ BoxShadow @ Rect(40.8333px×1.03333px at (143.016px,114.016px))
│  ├─ SolidColor rgba(0, 0, 0, 0) @ Rect(37px×40px at (12px,120.816px))
│  ├─ Image @ Rect(37px×40px at (12px,120.816px))
│  ├─ Text @ Rect(57.7666px×15.9833px at (53px,121.816px))</pre>                    
            </section>
            <section>
                <h2>Current progress</h2>
                <ul>
                    <li>Initial commit: September 22, 2015.</li>
                    <li>Two main developers: Glenn Watson (lead) and Patrick Walton.</li>
                    <li>
                        Today (February 18, 2016) we have implementations of essentially all
                        features of CSS that Servo supports.
                    </li>
                    <li>But there are many bugs still.</li>
                    <li>
                        The merge into upstream Servo landed today, behind a switch
                        (<code>-w</code>)!
                    </li>
                    <li>Shooting to turn on by default in the first half of the year.</li>
                </ul>
            </section>
            <section>
                <h2>Hardware requirements</h2>
                <ul>
                    <li>WebRender supports OpenGL ES 2.1 and OpenGL 3.x.</li>
                    <li>
                        We take advantage of OpenGL 3 features (loops in shaders and instanced
                        rendering) if available, but we do not require them.
                        <ul>
                            <li>
                                Though some features do not have ES2 fallbacks right now, notably
                                blurs.
                            </li>
                        </ul>
                    </li>
                    <li>
                        CPU fallbacks when no GPU is present or when the GPU drivers are broken
                        have been considered, but there are no plans yet.
                    </li>
                </ul>
            </section>
            <section>
                <h2>Project organization</h2>
                <ul>
                    <li>WebRender is largely developed separately from Servo.</li>
                    <li>
                        This means that the library can potentially be used outside of that browser
                        engine.
                    </li>
                    <li>
                        As an engine, WebRender could be used as a backend for any sort of 2D
                        graphics that CSS can describe.
                        <ul>
                            <li>…for example, mobile app UI.</li>
                        </ul>
                    </li>
                    <li>All WebRender needs is an OpenGL context to draw into.</li>
                </ul>
            </section>
            <section>
                <h1>How does WebRender work?</h1>
            </section>
            <section>
                <h2>The pipeline</h2>
                <img src=assets/pipeline.svg height=500 style="border: none">
            </section>
            <section>
                <h2>AABB Tree</h2>
                <div>Axis-aligned bounding box tree</div>
                <img style="background: white" src=assets/thin-AABB-tree.png height=300>
            </section>
            <section>
                <h2>Resource building</h2>
                <ul>
                    <li>
                        We traverse the AABB tree and find resources needed by the page.
                        <ul>
                            <li>Glyphs—rasterized on CPU with Quartz or FreeType (for now)</li>
                            <li>Images—scheduled for upload</li>
                            <li>
                                Paths (e.g. border radii, clipping masks)—rendered with a special
                                shader
                            </li>
                            <li>Shadows—also rendered with a special shader</li>
                        </ul>
                    </li>
                    <li>Resources are rasterized in parallel with a thread pool.</li>
                    <li>These objects are retained from frame to frame.</li>
                </ul>
            </section>
            <section>
                <h2>Node compilation</h2>
                <ul>
                    <li>We build a batch (VBO) for each visible node in parallel.</li>
                    <li>
                        Typically, all display items can be batched together to minimize state
                        changes.
                        <ul>
                            <li>
                                Exceptions are if we run out of texture space in an atlas or have a
                                clipping region that isn't a (rounded) rectangle.
                            </li>
                            <li>These exceptions are intended to be rare.</li>
                        </ul>
                    </li>
                </ul>
            </section>
            <section>
                <h2>Node collection and publishing</h2>
                <ul>
                    <li>
                        We gather together the individual node VBOs and ship them off to the
                        compositor thread, along with the resources that we built.
                    </li>
                </ul>
            </section>
            <section>
                <h2>Texture upload and resource rasterization</h2>
                <ul>
                    <li>We upload any textures that we received.</li>
                    <li>
                        Also, during this phase, we execute any rasterization operations that we
                        received (for example, box shadow operations, border radii, or text shadow
                        operations).
                        <ul>
                            <li>
                                Similar rasterization operations are batched together using the
                                same shader.
                            </li>
                            <li>This is a large win on complex workloads.</li>
                        </ul>
                    </li>
                    <li>All resources are uploaded into texture atlases.</li>
                </ul>
            </section>
            <section>
                <h2>Drawing</h2>
                <ul>
                    <li>
                        Draws are aggressively batched together, and to minimize state changes we
                        use one shader for most objects on the page, including text, borders,
                        shadows, etc.
                    </li>
                    <li>
                        We use intermediate surfaces for effects that require them (for example,
                        opacity or CSS filters).
                        <ul>
                            <li>
                                Similar operations are batched here too; for example, if we have
                                thousands of elements with the same CSS filter applied we will
                                render them in one batch.
                            </li>
                        </ul>
                    </li>
                </ul>
            </section>
            <section>
                <h2>Tricks</h2>
            </section>
            <section>
                <h2>Tricks: Instance drawing</h2>
                <h3>Motivation</h3>
                <ul>
                    <li>Observation: All CSS boxes are rectangles, usually axis-aligned.</li>
                    <li>
                        So submitting triangle vertices is wasteful: we're submitting six vertices
                        instead of two.
                    </li>
                    <li>Can we do better?</li>
                </ul>
            </section>
            <section>
                <h2>Tricks: Instance drawing</h2>
                <h3>Technique</h3>
                <ul>
                    <li>
                        OpenGL 3 has <code>glDrawElementsInstanced()</code> for repeated drawing of
                        the same vertices with different data each time.
                    </li>
                    <li>
                        We load a VBO with the vertices of a rectangle and, using that function,
                        submit per-instance data describing each CSS box.
                    </li>
                    <li>Particle systems in games often use a similar technique.</li>
                </ul>
            </section>
            <section>
                <h2>Tricks: On-GPU clipping</h2>
                <h3>Motivation</h3>
                <ul>
                    <li>
                        Observation 1: Clipping is expensive; pages do a lot of it.
                        <ul>
                            <li>If you do it with scissor or stencil, you incur state changes.</li>
                            <li>If you do it on the CPU, it's slow.</li>
                        </ul>
                    </li>
                    <li>
                        Observation 2: Most clipping in CSS involves clipping an axis-aligned
                        rectangle to another axis-aligned rectangle.
                    </li>
                    <li>
                        Observation 3: Clipping an axis-aligned rectangle to another axis-aligned
                        rectangle produces at most one axis-aligned rectangle.
                    </li>
                </ul>
            </section>
            <section>
                <h2>Tricks: On-GPU clipping</h2>
                <h3>Technique</h3>
                <ul>
                    <li>
                        For the common case, we pass the clip rectangle to the GPU and perform
                        the clipping there, in the vertex shader!
                    </li>
                    <li>
                        More complex axis-aligned clipping (for example, clipping out) is done on
                        the CPU as part of the node compiler.
                    </li>
                    <li>
                        We only use the stencil buffer when the clip region is in a different
                        transform space than the box being clipped. This is rare.
                    </li>
                </ul>
            </section>
            <section>
                <h1>Show me WebRender!</h1>
            </section>
            <section>
                <h2>Thank you!</h2>
                <h3>Questions?</h3>
            </section>
            <section>
                <h2>Image credits</h2>
                <ul>
                    <li>Haswell die photo: BenchmarkReviews.com</li>
                    <li>Broadwell die photo: Intel/AnandTech</li>
                    <li>Skylake die photo: techpowerup.com</li>
                    <li>AABB tree: Ming-Lun "Allen" Chou, <a>allenchou.net</a></li>
                </ul>
            </section>
        </div>
    </div>
    <script src="js/reveal.js"></script>
    <script>Reveal.initialize();</script>
</body>
</html>

