<html>
	<head>
        <meta charset="utf-8">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/night.css">
        <!--<link rel="stylesheet" href="css/theme/white.css">-->
        <style>
            .key {
                border: solid currentColor 1px !important;
                padding: 0px 12px !important;
                border-radius: 6px;
                font-size: smaller !important;
            }
            .reveal section img {
                box-shadow: none !important;
            }
        </style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
                    <h2>WebRender</h2>
                    <h4>
                        <div>Patrick Walton</div>
                        <div>@pcwalton</div>
                        <div>Lunch Talk @ Google</div>
                    </h4>
                </section>
				<section>
                    <div>This presentation rendered with WebRender!</div>
                </section>
				<section>
                    <h3>What is WebRender?</h3>
                    <div>A framework for rendering user interfaces on GPU.</div>
                </section>
				<section>
                    <img src="content/rust-logo.svg" style="border: none; width: 50%; height: 50%; background: none">
                </section>
				<section>
                    <h3>GPU APIs</h3>
                    <ul>
                        <li>
                            OpenGL 3.0 and OpenGL ES 3.0 backends
                            <ul><li>On Windows, optionally uses ANGLE</li></ul>
                        </li>
                        <li>
                            GPU code is factored out into a separate "driver" that can be swapped
                            out for other APIs
                        </li>
                        <li>
                            Long-term, want to experiment with <code>gfx-rs</code>
                            <ul><li>Would give us native Vulkan & Metal support</li></ul>
                        </li>
                    </ul>
                </section>
				<section>
                    <h3>Imaging model</h3>
                    <div>CSS-like, not PostScript-like</div>
                    <ul>
                        <li>Borders, box shadows, text shadows</li>
                        <li>3D transforms</li>
                        <li>Scroll frames, <code>position: sticky</code></li>
                        <li>Out-of-process <code>iframe</code>s</li>
                    </ul>
                </section>
                <section>
                    <h3>Animation</h3>
                    <div>
                        A flexible <em>property binding</em> system allows efficient handling of
                        animations
                    </div>
                </section>
				<section>
                    <h3>Multiprocess</h3>
                    <ul>
                        <li>
                            Display lists can be generated in an untrusted process and delivered
                            via IPC to a trusted process for rendering
                            <ul>
                                <li>
                                    Serialization code is memory-safe and autogenerated via
                                    <code>serde</code>
                                </li>
                            </ul>
                        </li>
                        <li>
                            Content from multiple processes can be composited into a single scene
                        </li>
                    </ul>
                </section>
                <section>
                    <h3>Multithreading</h3>
                    <ul>
                        <li>
                            <em>Renderer</em>: issues GPU commands
                            <ul><li>The only thread that interacts with the GPU</li></ul>
                        </li>
                        <li><em>Backend</em>: builds GPU batches/command buffers</li>
                        <li><em>Worker</em>: performs CPU-intensive tasks like glyph rasterization
                            <ul><li>A thread pool managed by <code>rayon</code></li></ul>
                        </li>
                    </ul>
                </section>
                <section>
                    <h3>Debugging</h3>
                    <ul>
                        <li>
                            Scenes can be saved into YAML or binary formats
                            <ul>
                                <li>
                                    <span class="key">Ctrl</span>
                                    <span class="key">Shift</span>
                                    <span class="key">3</span>
                                    in Firefox
                                </li>
                            </ul>
                        </li>
                        <li>Can be replayed with <code>wrench</code></li>
                    </ul>
                </section>
                <section>
                    <h3>Profiling</h3>
                    <img src="content/profiler.png" style="width: 65%">
                </section>
                <section>
                    <h3>How is WebRender different?</h3>
                </section>
                <section>
                    <h3>Traditional 2D pipeline</h3>
                    <img src="content/pipeline-traditional.svg" style="background: none; border: none;">
                </section>
                <section>
                    <h3>Traditional advantages</h3>
                    <ul>
                        <li>Compositing is cheap</li>
                        <li>Translations are fast (touch scrolling)</li>
                        <li>Can leverage hardware layers (sometimes)</li>
                        <li>Encounters fewer GPU driver bugs ðŸ˜‰</li>
                    </ul>
                </section>
                <section>
                    <h3>Traditional disadvantages</h3>
                    <ul>
                        <li>High memory usage</li>
                        <li>High overdraw</li>
                        <li>Layerization heuristics are complicated for developers</li>
                    </ul>
                </section>
                <section>
                    <h3>WebRender pipeline</h3>
                    <img src="content/pipeline-webrender.svg" style="background: none; border: none;">
                </section>
                <section>
                    <h3>Brushes and pictures</h3>
                    <div>Instead of layers, WebRender uses:</div>
                    <ul>
                        <li>
                            <em>Brushes</em>: typically-small images cached on GPU and reused from
                            frame to frame
                            <ul>
                                <li>e.g. glyphs, images, border pieces</li>
                            </ul>
                        </li>
                        <li>
                            <em>Pictures</em>: temporary render targets, discarded after each frame
                            <ul>
                                <li>(Though this might change)</li>
                            </ul>
                        </li>
                    </ul>
                </section>
                <section>
                    <h3>Traditional painting</h3>
                    <div>
                        <img src="content/draw-traditional-0.png" style="width: 60%">
                    </div>
                </section>
                <section>
                    <h3>Traditional painting</h3>
                    <div>
                        <img src="content/draw-traditional-1.png" style="width: 60%">
                    </div>
                </section>
                <section>
                    <h3>Traditional painting</h3>
                    <div>
                        <img src="content/draw-traditional-2.jpg" style="width: 60%">
                    </div>
                </section>
                <section>
                    <h3>Traditional painting</h3>
                    <div>
                        <img src="content/draw-traditional-3.jpg" style="width: 60%">
                    </div>
                </section>
                <section>
                    <h3>Can we do better?</h3>
                </section>
                <section>
                    <h3>WebRender painting</h3>
                    <div>
                        <img src="content/draw-webrender-0.jpg" style="width: 60%">
                    </div>
                </section>
                <section>
                    <h3>WebRender painting</h3>
                    <div>
                        <img src="content/draw-traditional-2.jpg" style="width: 60%">
                    </div>
                </section>
                <section>
                    <h3>WebRender painting</h3>
                    <div>
                        <img src="content/draw-traditional-3.jpg" style="width: 60%">
                    </div>
                </section>
                <section>
                    <h3>Batch, Batch, Batch</h3>
                    <div>
                        <div>Consider a typical series of draw commands:</div>
                        <ul>
                            <li>Solid Color</li>
                            <li>Solid Color</li>
                            <li>Text</li>
                            <li>Solid Color</li>
                            <li>Image</li>
                            <li>Solid Color</li>
                        </ul>
                    </div>
                </section>
                <section>
                    <h3>Batch, Batch, Batch</h3>
                    <div>
                        <div>Without opaque reordering, the batches are:</div>
                        <ol>
                            <li>2x Solid Color</li>
                            <li>Text</li>
                            <li>Solid Color</li>
                            <li>Image</li>
                            <li>Solid Color</li>
                        </ol>
                    </div>
                </section>
                <section>
                    <h3>Batch, Batch, Batch</h3>
                    <div>
                        <div>But with opaque reordering:</div>
                        <ol>
                            <li>4x Solid Color</li>
                            <li>Text</li>
                            <li>Image</li>
                        </ol>
                    </div>
                </section>
                <section>
                    <h3>But does it matter?</h3>
                    <h3>Aren't GPUs really fast?</h3>
                </section>
                <section>
                    <img src="content/opaque-pass-perf.svg">
                    <div style="font-size: 60%;">2017 MacBook Pro, Intel HD 630</div>
                </section>
                <section>
                    <h3>WebRender disadvantages</h3>
                    <ul>
                        <li>
                            Rendering translations can be more costly
                            <ul>
                                <li>Though not by much, in most cases</li>
                            </ul>
                        </li>
                        <li>Leans on the GPU more</li>
                    </ul>
                </section>
                <section>
                    <h3>WebRender advantages</h3>
                    <ul>
                        <li>Eliminates memory/performance tradeoffs</li>
                        <li>Reduces overdraw</li>
                        <li>Simpler for app developers to understand</li>
                        <li><em>Works more like a game engine.</em></li>
                    </ul>
                </section>
                <section>
                    <blockquote style="font-size: smaller">
                        &ldquo;When  path rendering  is  fully  GPU-accelerated,  a  retained  model
                        of  rendering  is  more  appropriate  and  efficient.   We  believe  web
                        browsers should behave more like video games in this respect to
                        exploit the GPU.&rdquo;
                    </blockquote>
                    <div style="text-align: right; font-size: 60%;">
                        &mdash;Kilgard & Bolz,
                        NVIDIA,
                        "GPU-Accelerated Path Rendering",
                        SIGGRAPH Asia 2012
                    </div>
                </section>
                <section>
                    <h3>Pathfinder</h3>
                    <div><em>Coming soonâ€¦</em></div>
                </section>
                <section>
                    <h3>GPU font rendering</h3>
                    <ul>
                        <li>Experimental!
:                            <ul>
                                <li><code>--features=pathfinder</code></li>
                            </ul>
                        <li>Strives to match the native system rendering</li>
                        <li>Uses OS libraries for font loading, hinting, etc.</li>
                    </ul>
                </section>
                <section>
                    <h3>GPU path rendering</h3>
                    <ul>
                        <li>Separate problem from font rendering</li>
                        <li>Needs some fundamental work, but promising so far</li>
                        <li>
                            See SVG demo at
                            <a href="http://github.com/pcwalton/pathfinder">
                                http://github.com/pcwalton/pathfinder
                            </a>
                        </li>
                    </ul>
                </section>
                <section>
                    <h3>Pathfinder long-term</h3>
                    <ul>
                        <li>Delightfully crisp pinch zooming and transformation of text</li>
                        <li>Make WebRender able to render SVG</li>
                    </ul>
                </section>
                <section>
                    <h3>Pathfinder non-goal</h3>
                    <ul>
                        <li>Make Pathfinder easy to use independent of WebRender
                        <ul>
                            <li>Too low-level to be realistically appropriate for apps</li>
                        </ul>
                        <li>WebRender is the one-stop shop for 2D rendering</li>
                    </ul>
                </section>
                <section>
                    <h3>WebRender status</h3>
                    <ul>
                        <li>Shipping in Firefox Nightly behind a preference</li>
                        <li>
                            On by default for a small percentage of Nightly users
                            <ul>
                                <li>Currently gathering Telemetry data for studies</li>
                            </ul>
                        </li>
                        <li>Burning down remaining bugs</li>
                    </ul>
                </section>
                <section>
                    <h3>Embeddability</h3>
                    <ul>
                        <li>WebRender isn't just a Firefox component</li>
                        <li>Some experimental UI toolkits in the community are using it</li>
                    </ul>
                </section>
                <section>
                    <h3>Thank you!</h3>
                    <h4>Questions?</h4>
                    <h4><a href="http://github.com/servo/webrender">
                        http://github.com/servo/webrender
                    </a></h4>
                </section>
			</div>
		</div>
		<script src="js/reveal.js"></script>
		<script>
			Reveal.initialize({
                slideNumber: true,
            });
		</script>
	</body>
</html>

: